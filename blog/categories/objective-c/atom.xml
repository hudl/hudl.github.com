<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | The Raw Bits]]></title>
  <link href="http://hudl.github.com/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://hudl.github.com/"/>
  <updated>2012-11-08T15:19:12-06:00</updated>
  <id>http://hudl.github.com/</id>
  <author>
    <name><![CDATA[Hudl]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Synchronous AFNetworking]]></title>
    <link href="http://hudl.github.com/blog/2012/11/08/synchronous-afnetworking/"/>
    <updated>2012-11-08T13:42:00-06:00</updated>
    <id>http://hudl.github.com/blog/2012/11/08/synchronous-afnetworking</id>
    <content type="html"><![CDATA[<p>Almost everyone is using <a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a> these days, but one issue I've ran in to a couple times is the lack of synchronous methods.</p>

<p>A little searching around the nets didn't produce much except the <a href="http://stackoverflow.com/questions/7969865/can-afnetworking-return-data-synchronously-inside-a-block">"Don't make synchronous requests"</a> suggestion. In general, that's the best answer; handling queues/threads/operations/etc becomes tricky pretty quickly. But what about those times when you know synchronous is the right way to go?</p>

<p>First off, spend a little time in the <a href="https://developer.apple.com/library/ios/#documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html">GCD docs</a>. Playing with these methods can lead to deadlocks if you aren't careful. After that, check out the method below. It has nearly the same signature as <code>- [AFHttpClient postPath:parameters:success:failure:]</code>, but instead of success and failure callbacks it <em>returns</em> the result. In my case, it returns <code>nil</code> for a failure, the resulting object, or "Great Success" if the request completed successfully but without a response body.</p>

<p><div><script src='https://gist.github.com/4041156.js?file='></script>
<noscript><pre><code>- (id)postSyncToPath:(NSString *)path parameters:(NSDictionary *)parameters
{
    __block id result = nil;
    dispatch_group_t group = dispatch_group_create();

    dispatch_group_enter(group);

    [super postPath:path parameters:parameters success:^(AFHTTPRequestOperation *op, id resultObject)
     {
         // executed on the main thread. make it quick!
         if (resultObject != nil)
         {
             result = resultObject;
         }
         else
         {
             result = @&quot;Great Success!&quot;;
         }
         dispatch_group_leave(group);

     } failure:^(AFHTTPRequestOperation *op, NSError *err)
     {
         NSLog(&quot;postSyncToPath Error: %@&quot;, error);

         dispatch_group_leave(group);
     }];

    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);

    return result;
}</code></pre></noscript></div>
</p>

<p><strong>Be sure to call this method on a queue other than the main queue.</strong> I <em>implore</em> you. The calling queue will be blocked until the network request returns. If you do this on the main queue, you'll have some very unhappy users. Note the dispatch block below is on a low priority queue.</p>

<p><div><script src='https://gist.github.com/4041333.js?file='></script>
<noscript><pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^
{
    NSArray *posts = @[
        @{ @&quot;title&quot;: @&quot;Making AFNetworking Synchronous&quot; },
        @{ @&quot;title&quot;: @&quot;Preparing for Season: Load Testing&quot; },
        @{ @&quot;title&quot;: @&quot;UI Prototyping at Hudl&quot; }
    ];
    NSString *path = @&quot;/posts&quot;;
    
    for (NSDictionary *post in posts)
    {
        NSDictionary *result = [afHttpClient postSyncToPath:path parameters:post];
        if (result != nil)
        {
            NSLog(@&quot;Result: %@&quot;, result);
        }
    }
}</code></pre></noscript></div>
</p>

<p>That's it for quick and dirty synchronous AFNetworking. It'll turn your nasty, callback spaghetti code in to pretty, ordered procedural code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Making NSArray More Functional]]></title>
    <link href="http://hudl.github.com/blog/2012/04/03/making-nsarray-more-functional/"/>
    <updated>2012-04-03T13:24:00-05:00</updated>
    <id>http://hudl.github.com/blog/2012/04/03/making-nsarray-more-functional</id>
    <content type="html"><![CDATA[<p>Having spent a lot of time developing in C#, Ruby, and Javascript, I've had the pleasure of using frameworks like Linq, ActiveRecord, and Underscore.js. Each one has it's own set of similar functional methods that make working with collections a lot more fun. Objective-C on the other hand has beauties like
<div><script src='https://gist.github.com/2295259.js?file=existing.h'></script>
<noscript><pre><code>- (void)enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop)block;
- (NSUInteger)indexOfObjectPassingTest:(BOOL (^)(id obj, NSUInteger idx, BOOL *stop))predicate;</code></pre></noscript></div>

and is missing pretty much everything else.</p>

<p>Rather than haphazardly cram together a bunch of built-in <code>NSArray</code> methods every time we wanted to manipulate an array, we wrote our own methods. Some of them may be fairly naive implementations, but they get the job done and the names are so much easier to remember.</p>

<p>The good news is Objective-C supports Categories, so adding the methods to <code>NSArray</code> was a breeze. Checkout the <a href="https://github.com/hudl/NSArray-FunctionalHelper">Github repository</a> to see all the methods and add more of your own.</p>

<h2>Examples</h2>

<p><div><script src='https://gist.github.com/2295259.js?file=examples.m'></script>
<noscript><pre><code>// A new array that only contains valid objects
NSArray *validObjects = [allObjects where:^(id obj) { return [obj isValid]; }];

// A new array with the first five valid objects
NSArray *firstFive = [validObjects take:5];

// A new array with valid objects 6-10
NSArray *nextFive = [[validObjects skip:5] take:5];

// A new array containing only the objectIDs of each valid object
NSArray *objectIds = [validObjects map:^(id obj) { return [obj objectID]; }];

// A dictionary that has objectIDs for keys and the original objects as values
NSDictionary *objectIdsToObjects = [validObjects toDictionary:^(id obj) { return [obj objectID]; }];</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
</feed>
