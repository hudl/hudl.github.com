
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Preparing for Season: Load Testing - The Raw Bits</title>
  <meta name="author" content="Hudl">

  
  <meta name="description" content="Introduction Hudl is fundamentally a technology company, and our area of focus is sports. Since our namesake application is web-based, and most of &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hudl.github.com/blog/2012/10/05/load-testing">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="The Raw Bits" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">The Raw Bits</a></h1>
  
    <h2>@hudl #realtalk</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hudl.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Preparing for Season: Load Testing</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-05T00:00:00-05:00" pubdate data-updated="true">Oct 5<span>th</span>, 2012</time>
        
      </p>
    
  </header>


<div class="entry-content"><h2>Introduction</h2>

<p>Hudl is fundamentally a technology company, and our area of focus is sports. Since our namesake application is web-based, and most of our partners are football coaches, that presents us with an interesting situation: our usage changes dramatically with the time of the year (and of the week, for that matter). In some ways, that&#8217;s good. The offseason gives us an opportunity to catch our breath, tackle bigger features, and concentrate on adding more value to our product.</p>

<p>However, since our public launch in 2009, we&#8217;ve expanded our user base significantly each year, and we don&#8217;t really feel that full impact until the last couple weeks of August when football programs move into full swing. Most other web applications grow at a steady pace, so scaling is something they deal with regularly. They&#8217;ll likely add some more hardware, optimize their application code, tweak settings, and repeat frequently. Because their site load does not generally recede for longer than a day or so, this strategy will work well.</p>

<p>Hudl&#8217;s usage is not nearly so regular. Not only is it strongly seasonal, each season brings significantly more users than our application has ever seen before. So how do we prepare? We rely on simulation during the offseason. We work hard to predict our fall numbers and emulate our upcoming usage in order to find bottlenecks and weak links before the real season starts. Simulation is never as good as the real thing, but just like the teams who depend on us, we rely on our preparation to take us successfully through the season.</p>

<h2>Analyzing Current Usage</h2>

<p>Before we can simulate our users&#8217; behavior, we have to understand what it is they do. For this, we draw from two main sources of information. The primary is our usage logs. We do extensive logging throughout our application code, and all that data winds up in <a href="http://splunk.com">Splunk</a> where we can search and analyze it. We also use Google Analytics to tell us where users spend most of their time on our site. We look for the HTTP endpoints and services that are most heavily used during our previous season, then factor in recent trends because we&#8217;ve added several new features since December. From here, we&#8217;ll pick off the most used web requests to emulate. Typically, we draw a line at about 1% or more of the total requests, but it&#8217;s not an absolute rule because we know from experience that certain services are likely to be costly even if they are not used frequently.</p>

<p>As with all simulation, there are some inaccuracies. Our usage data is good, but it isn&#8217;t perfect. Even if it were, we wouldn&#8217;t be able to emulate the usage perfectly, and we leave many of the lesser-used features untested due to resource constraints. And, as I mentioned before, we&#8217;re relying on numbers from the prior season which is likely to differ from this season&#8217;s numbers because of new designs and features. We have ways to mitigate these risks, but that&#8217;s another topic.</p>

<h2>Tools</h2>

<p>Our load testing suite is built on Microsoft&#8217;s Visual Studio Ultimate load testing framework. Running on a .NET stack, we&#8217;re already heavily invested in Microsoft&#8217;s development tools, so it was a natural choice. The starting point for these load tests is recording web tests.</p>

<p><img src="http://static.hudl.com/cms/img/rawbits/vs_webtest.png" title="Visual Studio .webtest screenshot" alt="Visual Studio .webtest screenshot" /></p>

<p>Web tests can make any kind of HTTP request, and the recorder will automatically set appropriate headers for HTML, JSON and SOAP requests. We intentionally keep the .webtest files instead of converting them into C# code because they can be maintained through the GUI, which makes them more accessible for maintenance by even those not intimately acquainted with the suite. To keep the tests in that format required some significant infrastructure in code, though. The framework is delightfully modularized so we can build plugins at all levels of the test to capture, extract, and/or inject data.</p>

<div><script src='https://gist.github.com/3841524.js?file=ExtractPublishedClipId.cs'></script>
<noscript><pre><code>using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Xml.Linq;
using Microsoft.VisualStudio.TestTools.WebTesting;

namespace Hudl.WebApp.Tests.TestsCore.ExtractionRules
{
    [DisplayName(&quot;Extract Published Clip ID&quot;)]
    [Description(&quot;For a CreateClip web service request, extracts the newly-created Clip ID value and inserts it into the ID collection specified by the Context parameter name.&quot;)]
    public class ExtractPublishedClipId : ExtractionRule
    {
        private static readonly XNamespace DefaultNamespace;

        static ExtractPublishedClipId()
        {
            DefaultNamespace = &quot;http://tempuri.org/&quot;;
        }

        public override void Extract(object sender, ExtractionEventArgs e)
        {
            var bodyString = e.Response.BodyString;
            var clipId = GetClipId(bodyString);

            if (!clipId.HasValue)
            {
                e.Message = &quot;Extraction of Published Clip ID failed. Result text: &quot; + Environment.NewLine +
                            e.Response.BodyString;
                e.Success = false;
                return;
            }

            var clipIds = e.WebTest.Context[ContextParameterName] as ICollection&lt;long&gt;;
            clipIds.Add(clipId.Value);

            e.Success = true;
        }

        private static long? GetClipId(string bodyString)
        {
            var bodyDoc = XDocument.Parse(bodyString);
            var resultElement = bodyDoc.Descendants(DefaultNamespace + &quot;CreateClipResult&quot;).SingleOrDefault();

            if (resultElement == null)
            {
                return null;
            }

            var createClipResultValue = resultElement.Value;
            var clipId = Convert.ToInt64(createClipResultValue);
            return clipId;
        }
    }
}</code></pre></noscript></div>


<p>The most important part of our web tests is the seed data. We need it to be as accurate as possible, so we harvest real user data, denormalize it, and insert it into a seed database. We created a tool to do this, of course, and it currently takes about six hours to create this database. Fortunately, we don&#8217;t need to do it very often as the data is not changed during testing.</p>

<p>Feeding the data into the tests is tricky because the DataSources the framework provides cannot take criteria. When you&#8217;re emulating a user on Hudl, the data has to be specific to that user or the test is pointless. We leveraged the WebTestPlugin class to create our own datasources that query the seed database for a related set of data and cache it for use during subsequent iterations. It is also lazy loaded. This keeps the memory footprint on the test agents as low as we can keep it, and eases the strain on the seed database (which is located centrally on the load test controller).</p>

<div><script src='https://gist.github.com/3841573.js?file=AnnotationsDataSource.cs'></script>
<noscript><pre><code>using System;
using System.Data;
using System.Data.SqlClient;

namespace Hudl.WebApp.Tests.TestsCore.DataSources
{
    public class AnnotationsDataSource : ModifiableQueueBasedDataSource&lt;long&gt;
    {
        private readonly long _userId;

        public AnnotationsDataSource(long userId)
        {
            _userId = userId;
            HasBeenModified = false;
        }

        protected override void LoadItems()
        {
            const string annotationDataQuery = @&quot;SELECT [AnnotationId]
                                                 FROM [AnnotationData] 
                                                 WHERE [UserId] = @UserId&quot;;
            var sqlCommand = new SqlCommand(annotationDataQuery);
            sqlCommand.Parameters.Add(&quot;@UserId&quot;, SqlDbType.BigInt).Value = _userId;

            UsingDataReader(sqlCommand, EnqueueAnnotationData);
        }

        private void EnqueueAnnotationData(SqlDataReader sqlDataReader)
        {
            var annotationId = Convert.ToInt64(sqlDataReader[&quot;AnnotationId&quot;]);

            DataItems.Enqueue(annotationId);
        }

        public override string ToString()
        {
            var value = String.Format(&quot;AnnotationsDataSource: Is loaded: {0}, {1} items, User {2}, Has been modified: {3}&quot;, IsLoaded, DataItems.Count, _userId, HasBeenModified);
            return value;
        }
    }
}</code></pre></noscript></div>




<div><script src='https://gist.github.com/3841578.js?file=AnnotationsDataSourcePlugin.cs'></script>
<noscript><pre><code>using System.ComponentModel;
using Hudl.WebApp.Tests.TestsCore.DataSources;
using Microsoft.VisualStudio.TestTools.WebTesting;

namespace Hudl.WebApp.Tests.TestsCore.Plugins
{
    [DisplayName(&quot;Annotations DataSource&quot;)]
    [Description(&quot;Reads Annotation IDs from the context and assigns values to context parameters.&quot;)]
    public class AnnotationsDataSourcePlugin : WebTestPlugin
    {
        [DisplayName(&quot;DataSource Context Parameter Name&quot;)]
        [Description(&quot;The name of the context parameter which holds the DataSource object.&quot;)]
        [DefaultValue(&quot;AnnotationsDataSource&quot;)]
        public string DataSourceContextParameterName { get; set; }

        [DisplayName(&quot;AnnotationId Context Parameter Name&quot;)]
        [Description(&quot;The name of the context parameter which will be assigned the annotation ID value.&quot;)]
        [DefaultValue(&quot;AnnotationId&quot;)]
        public string AnnotationIdContextParameterName { get; set; }

        public override void PreWebTest(object sender, PreWebTestEventArgs e)
        {
            base.PreWebTest(sender, e);
            var webTextContext = e.WebTest.Context;

            var annotationsDataSource = webTextContext[DataSourceContextParameterName] as IDataSource&lt;long&gt;;

            var annotationId = annotationsDataSource.GetNext();
            webTextContext[AnnotationIdContextParameterName] = annotationId;
        }
    }
}</code></pre></noscript></div>


<h2>Running in the Cloud</h2>

<p>As you might expect, because Hudl runs on EC2, we also test on and against EC2. We spin up an exact replica of our production environment and enough instances to simulate the number of simultaneous users we want to test. Microsoft recommends each load test agent only run 1000 concurrent users, and we generally stick to that. We need to add one more server to be the controller for the test agents. The controller coordinates the tests, feeds the agents seed data, and collects and aggregates result data. We often run these tests for hours at a time so we can examine the site behavior during and after long periods of stress. When we&#8217;re through, we can terminate these instances so we only spend money when we&#8217;re actively testing.</p>

<h2>Wrapping Up</h2>

<p>While the tests are running, we watch site performance and server metrics. Finding and addressing these bottlenecks is a post in itself, but we&#8217;re especially interested in seeing how our databases perform, where the expensive operations are and if they can be remedied, and how the system reacts when we kill servers. Once the tests have completed, we can critique performance: How many errors did we see, and are they legitimate? Why did these requests take so long? What can we do to improve our average page speed?</p>

<p>The answers to these questions will determine the success of our season and the success of many of our partners&#8217; seasons.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">TysonS</span></span>

      








  


<time datetime="2012-10-05T00:00:00-05:00" pubdate data-updated="true">Oct 5<span>th</span>, 2012</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/devops/'>DevOps</a>, <a class='category' href='/blog/categories/load-testing/'>Load-Testing</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://hudl.github.com/blog/2012/10/05/load-testing/" data-via="" data-counturl="http://hudl.github.com/blog/2012/10/05/load-testing/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2012/06/01/ui-prototyping-at-hudl/" title="Previous Post: UI Prototyping at Hudl">&laquo; UI Prototyping at Hudl</a>
      
      
        <a class="basic-alignment right" href="/blog/2012/11/08/synchronous-afnetworking/" title="Next Post: Synchronous AFNetworking">Synchronous AFNetworking &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/06/20/post-mortem/">Post-Mortem for Internal Incident on June 13</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/11/08/synchronous-afnetworking/">Synchronous AFNetworking</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/05/load-testing/">Preparing for Season: Load Testing</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/01/ui-prototyping-at-hudl/">UI Prototyping at Hudl</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/04/03/making-nsarray-more-functional/">Making NSArray More Functional</a>
      </li>
    
  </ul>
</section>






  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Hudl -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
